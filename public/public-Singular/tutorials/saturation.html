Singular online<html>
  <head>
    <title>Tutorial: Saturation of polynomial ideals</title>
  </head>
<body>

<div>
  <h4>Tutorial: Saturation of polynomial ideals</h4>

  <p>For two ideals $I,J$ in a polynomial ring $R$ the saturation of $I$ with respect to $J$ is defined by

    $$\text{sat}(I:J)=\{f\in R\mid \exists k\in\mathbb{N}: f^k\cdot J\subseteq I\}=\bigcap_{k\in\mathbb{N}} I:J^k.$$

    It describes, geometrically, the closure of the complement of $V(J)$ in $V(I)$ (where $V(I)$, $V(J)$ denotes the affine varieties defined by $I$, $J$ respectively).</p>

  <p>The saturation allows us, amongst other things, to show that an affine hypersurface $V(f)$ has no singular points outside the origin. For that we need to construct the sum $I$ of the Jacobian $J_f$ with the ideal generated by $f$, and saturate it with respect to the maximal ideal $\mathfrak{m}$ corresponding to the origin. Consider the following example (click on each line to pipe it to the right side):</p>

  <code>ring R = 0,(x,y,z),dp;</code><br>
  <code>poly f = x^11+y^5+z^(3*3)+x^(3+2)*y^(3-1)+x^(3-1)*y^(3-1)*z^3+x^(3-2)*y^3*(y^2)^2;</code><br>
  <code>ideal J = jacob(f);</code><br>
  <code>ideal I = J+f;</code><br>
  <code>ideal m = x,y,z;</code><br>

  <p>Then
    $$V(f) \text{ has no singular point outside the origin} \quad \Longleftrightarrow \quad \text{sat}(I,\mathfrak{m})=\langle 1\rangle.$$
    To compute the saturation, we successively compute quotients until we reach an eventual point of stabilization.</p>

  <code>ideal satI = quotient(I,m);</code><br>
  <code>while (reduce(satI,std(I))!=0)</code><br>
  <code>{</code><br>
  <code>  I = satI;</code><br>
  <code>  satI = quotient(I,m);</code><br>
  <code>}</code><br>
  <code>satI;</code><br>

  <p>Note that the method described above works for saturations at arbitrary ideals. It is officially available as the procedure \({\tt sat}\) in the library \({\tt elim.lib}\), takes two ideals as input and returns a list containing the saturation $\text{sat}(I,J)$ as well as an integer $k\in\mathbb{Z}$ such that $\text{sat}(I,J)=I:J^k$.</p>

  <code>LIB "elim.lib";</code><br>
  <code>sat(J+f,m);</code><br>

  <p>However, the maximal ideal generated by all variables is a very interesting ideal to saturate with (for example. it allows allows to check an ideal for monomials), and there is one other method for saturating with respect to it:</p>

  <p>Given a Groebner basis $G$ of our ideal $I$ with respect to a lexicographical ordering. It can then be shown that the following set is a Groebner basis of $\text{sat}(I,x_n)$, where $x_n$ denotes the lexicographically smallest variable (see Sturmfels, Groebner bases and convex polytopes):

    $$ G'=\left\{\frac{g}{x_n^k} \;\;\Big\vert \;\; g\in G, \;\; x_n^k \text{ highest power of }x_n \text{ dividing }g\right\}$$
  </p>

  <p>So in order to saturate our ideal $I$ with respect to all variables, we compute our Groebner bases with respect to different lexicographical orderings. Note that, supposing $z$ is the lexicographically smallest variable, the highest power of $z$ dividing a polynomial is the power of $z$ appearing in the leading monomial.</p>

  <code>I = J+f; // let's start over again</code><br>
  <code>ring S = 0,(x,y,z),lp;</code><br>
  <code>ideal I = imap(R,I);</code><br>
  <code>ideal G = std(I);</code><br>
  <code>ideal Gdash;</code><br>
  <code>poly g;</code><br>
  <code>int k;</code><br>
  <code>for (int i=1; i<=size(G); i++)</code><br>
  <code>{</code><br>
  <code>  g = G[i];</code><br>
  <code>  k = leadexp(g)[3];</code><br>
  <code>  Gdash[i] = g/(z^k);</code><br>
  <code>}</code><br>

  <p>Because $G'$ is not minimal yet, we can simplify it so that it becomes easier to view at. And we see that the saturated ideal has already become the whole ring, so that saturating it with respect to variables $x$ and $y$ becomes obsolete.</p>

  <code>Gdash = simplify(Gdash,32+2);</code><br>
  <code>Gdash;</code><br>

  <p>Note that if our ideal I had been homogeneous, we would've been allowed to use a graded ordering with lexicographical tiebreaker instead.</p>

  <p>Now in order to save the session, click the "save" button. It allows you to save your input and the output you have gotten seperately. This way, you can recreate the current state of the session by loading the input file using the "load" button. Singular will then recreate all the steps in this session.</p>

</div>

<!-- <div> -->
<!--   <h4>Tutorial: Hacking the Groebner basis computation</h4> -->

<!--   <p>Starting with the next release, Singular will include infrastructure that allows for hacking its Groebner basis computation. How it works: whenever a new Groebner basis element is found, the Groebner basis algorithms calls an injected procedure which is allowed to change anything in the current computation.</p> -->

<!--   <p>Caveat: to produce a working hack, knowledge in C++ and in Singular's source are needed.</p> -->

<!--   <h5>Example 1: printing out each new Groebner basis element as it is found</h5> -->

<!--   <code>LIB "std_demo.so";</code><br> -->
<!--   <code>ring r = 0,(a,b,c,d),dp;</code><br> -->
<!--   <code>ideal I = a+b+c+d,ab+ad+bc+cd,abc+abd+acd+bcd,abcd-1;</code><br> -->
<!--   <code>std_with_display(I);</code><br> -->

<!--   <h5>Example 2: dividing each new Groebner basis element by the maximal possible monomial</h5> -->

<!--   <p>When computing a Groebner basis with the goal of saturating the ideal with respect to all variables, one my divide any basis element by the maximal possible monomial that divides it. This effectively enlarges the ideal, but not beyond the full saturation.</p> -->

<!--   <p>Doing so, the basis elements become simpler and of lower degree, which is favourable for reductions with respect to them and which can lead to significant speedups. As a drawback, this potentially breaks any Hilbert driven strategy.</p> -->


<!--   <code>ring r = 0,(x,y,z),dp;</code><br> -->
<!--   <code>ideal I = intersect(ideal(x+y,y+z),ideal(z5));</code><br> -->
<!--   <code>std(I);</code><br> -->
<!--   <code>satstd(I);</code><br> -->

<!--   <h5>Example 3: abort Groebner basis computation when new Groebner basis element has monomial initial form</h5> -->

<!--   <p>If you want to check a specific weight vector for containment in the tropical variety, you need to calculate whether its initial form contains a monomial ideal. Determining the initial ideal requires a Groebner basis computation, which might take long depending on the difficulty of the ideal. </p> -->

<!--   <p>However, if we encounter a basis element whose initial form is a monomial during the computation, it is clear that we have an answer to our problem and may abort the computation.</p> -->

<!--   <p>The following ideal is an example of an ideal, whose (restricted) Groebner fan is not the normal fan of a polytope (see: Anders Jensen, A non-regular Groebner fan, Discrete Comput. Geom. 37 (2007)):</p> -->

<!--   <code>ring r0 = 0,(a,b,c,d),wp(2,6,4,1);</code><br> -->
<!--   <code>ideal I = acd+a2c-ab,ad2-c,ad4+ac;</code><br> -->
<!--   <code>satstd(I);</code><br> -->
<!--   <code>satstdWithInitialCheck(I);</code><br> -->

<!--   <code>ring r1 = 0,(a,b,c,d),wp(2,1,2,2);</code><br> -->
<!--   <code>ideal I = fetch(r0,I);</code><br> -->
<!--   <code>satstdWithInitialCheck(I);</code><br> -->

<!--   <code>ring r2 = 0,(a,b,c,d),wp(4,1,2,5);</code><br> -->
<!--   <code>ideal I = acd+a2c-ab,ad2-c,ad4+ac;</code><br> -->
<!--   <code>satstdWithInitialCheck(I);</code><br> -->

<!--   <p>The three weight vectors above generate the three rays of the tropical variety of I, notice how they sum up to a multiple of (1,1,1,1), satisfying the balancing condition.</p> -->

<!-- </div> -->

</body>
</html>
